# Poll App - AI Development Rules
# Next.js 15 Polling Application with Supabase & TypeScript

## ðŸ—ï¸ PROJECT ARCHITECTURE

### Folder Structure Requirements
- Follow Next.js 13+ App Router structure with `/app` directory
- Organize components into logical subdirectories:
  - `/components/auth/` - Authentication components (LoginForm, RegisterForm)
  - `/components/layout/` - Layout components (Navbar, Footer)
  - `/components/polls/` - Poll-specific components
  - `/components/ui/` - Reusable UI components (shadcn/ui)
- Use `/app/api/` for API routes with proper nesting:
  - `/app/api/auth/` - Authentication endpoints
  - `/app/api/polls/` - Poll CRUD operations
- Maintain utility folders:
  - `/types/` - TypeScript type definitions
  - `/hooks/` - Custom React hooks
  - `/utils/` - Pure utility functions
  - `/lib/` - Third-party library configurations

### File Naming Conventions
- Use PascalCase for React components (e.g., `PollCard.tsx`)
- Use camelCase for hooks (e.g., `usePolls.ts`)
- Use kebab-case for utility files (e.g., `date-utils.ts`)
- Use lowercase for API routes (e.g., `route.ts`)

## ðŸ” AUTHENTICATION & DATABASE

### Supabase Integration Rules
- ALWAYS use `@supabase/ssr` package for server-side operations
- Use `createServerClient` in middleware and API routes
- Use `createClientComponentClient` in client components
- Import Supabase client from `/lib/supabaseClient.ts`
- Implement proper error handling for auth operations
- Use TypeScript interfaces for database schema types

### Authentication Patterns
- Protect routes using `middleware.ts` with proper redirects
- Use React Context (`AuthContext`) for client-side auth state
- Implement loading states for auth operations
- Handle auth errors gracefully with user-friendly messages

## ðŸ“ FORM HANDLING

### React Hook Form + Shadcn/ui Requirements
- ALWAYS use `react-hook-form` with `@hookform/resolvers/zod` for validation
- Use shadcn/ui form components: `Form`, `FormField`, `FormItem`, `FormLabel`, `FormControl`, `FormMessage`
- Structure forms with proper TypeScript interfaces:
  ```typescript
  interface PollFormData {
    title: string;
    description?: string;
    options: string[];
    expiresAt?: Date;
  }
  ```
- Implement form validation with Zod schemas
- Use `useForm` hook with proper default values and validation modes
- Handle form submission with loading states and error handling

### Form Component Pattern
```typescript
const PollForm = () => {
  const form = useForm<PollFormData>({
    resolver: zodResolver(pollSchema),
    defaultValues: { title: '', options: ['', ''] }
  });
  
  const onSubmit = async (data: PollFormData) => {
    // Handle submission with proper error handling
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields using FormField components */}
      </form>
    </Form>
  );
};
```

## ðŸŽ¨ UI & STYLING

### Component Design Rules
- Use shadcn/ui components as building blocks
- Implement responsive design with Tailwind CSS classes
- Follow consistent spacing and typography patterns
- Use semantic HTML elements for accessibility
- Implement proper loading and error states

### Modular Component Architecture
- Create small, focused, reusable components
- Use composition over inheritance
- Implement proper prop interfaces with TypeScript
- Use React.forwardRef for components that need ref forwarding
- Export components with proper default exports

## ðŸ”§ DEVELOPMENT PATTERNS

### TypeScript Requirements
- Use strict TypeScript configuration
- Define interfaces in `/types/index.ts` for shared types
- Use proper generic types for API responses
- Implement proper error types and handling
- Use `satisfies` operator for type safety where appropriate

### Custom Hooks Pattern
- Create custom hooks for data fetching and state management
- Use proper dependency arrays in useEffect
- Implement cleanup functions for subscriptions
- Handle loading, error, and success states
- Example pattern:
  ```typescript
  const usePolls = () => {
    const [polls, setPolls] = useState<Poll[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    
    // Implementation with proper error handling
    return { polls, loading, error, refetch };
  };
  ```

### API Route Standards
- Use proper HTTP methods (GET, POST, PUT, DELETE)
- Implement authentication checks in protected routes
- Return consistent JSON response formats
- Handle errors with appropriate HTTP status codes
- Use TypeScript for request/response types
- Implement proper CORS handling if needed

## ðŸ“¦ DEPENDENCIES & IMPORTS

### Import Organization
1. React and Next.js imports first
2. Third-party library imports
3. Internal imports (components, hooks, utils)
4. Type-only imports last

### Required Dependencies
- Core: `next`, `react`, `typescript`
- UI: `@radix-ui/*`, `tailwindcss`, `lucide-react`
- Forms: `react-hook-form`, `@hookform/resolvers`, `zod`
- Database: `@supabase/supabase-js`, `@supabase/ssr`
- Utils: `clsx`, `tailwind-merge`, `date-fns`

## ðŸš€ PERFORMANCE & BEST PRACTICES

### Optimization Rules
- Use Next.js Image component for images
- Implement proper loading states and skeleton screens
- Use React.memo for expensive components
- Implement proper error boundaries
- Use dynamic imports for code splitting when appropriate
- Optimize bundle size by importing only needed functions

### Code Quality
- Follow ESLint and Prettier configurations
- Write descriptive commit messages
- Use meaningful variable and function names
- Implement proper error handling throughout the application
- Add JSDoc comments for complex functions
- Use consistent code formatting and style

## ðŸ§ª TESTING CONSIDERATIONS

### Testing Strategy
- Write unit tests for utility functions
- Test form validation and submission
- Test authentication flows
- Mock Supabase client in tests
- Use React Testing Library for component tests

---

**Remember**: This is a polling application focused on user experience, type safety, and maintainable code. Always prioritize user feedback, proper error handling, and responsive design when implementing new features.